---
title: "Projet Pollution"
author: "BEX Roméo MARHEINEKE Linus "
date : today
format:
  revealjs: 
    theme: default
    title-slide-attributes:
        data-background-image: bg_slides.svg 
    transition: slide
---

# Objectifs du projet {background-color="#CAFFEF"}
::: {.incremental}
- Etablir une corrélation entre pollution en Occitanie et météo 
- Etablir une hiérarchie des villes en fonction du taux de pollution des principaux polluants 
:::


## Technicité et source {background-color="#CAFFEF"}
:::{.incremental}
- Bibilothèques : 
    + pandas
    + matplotlib
    + seaborn
    + os
    + geojson
  
- Diapositives : [Quarto](https://quarto.org/)
- Sources : [données SYNOP](https://public.opendatasoft.com/explore/dataset/donnees-synop-essentielles-omm/api/?sort=date)
           et [Atmo Occitanie](https://data-atmo-occitanie.opendata.arcgis.com/pages/liste-des-flux)
:::

## {background-video="video.mp4" background-video-loop="true" background-video-muted="true"}



# Analyse du code {background-color="#CAFFEF"}
```{.python code-line-numbers="2,3,4,5,6|9|12|15|18,19|22,23,24,25|27"}

import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import seaborn as sns
import os 

# Remplacez 'votre_fichier.csv' par le chemin vers votre fichier CSV
chemin_fichier_csv = 'Mesure_mensuelle_Region_Occitanie_Polluants_Principaux.csv'

# Charger le fichier CSV dans un DataFrame
df = pd.read_csv(chemin_fichier_csv)

# Créer un dégradé de couleurs pour la palette
couleurs = sns.color_palette("coolwarm", as_cmap=True)

# Créer un diagramme circulaire (camembert) pour la variable 'nom_dept'
plt.figure(figsize=(10, 8))
sns.set(style="whitegrid")  # Style de fond pour une meilleure lisibilité

# Tracer le camembert avec le dégradé de couleurs
df['nom_dept'].value_counts().plot.pie(autopct='%1.1f%%', startangle=140, cmap=couleurs)
plt.title('Répartition des données par département')
plt.axis('equal')  # Assure que le camembert est dessiné comme un cercle
plt.ylabel('')  # Supprimer l'étiquette de l'axe y pour plus de clarté

plt.show()
```

## Résultat : {background-color="#CAFFEF"}

```{python}

#fonctionne camembert dégradé de couleur 
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import LinearSegmentedColormap
import seaborn as sns
import os 

# Remplacez 'votre_fichier.csv' par le chemin vers votre fichier CSV
chemin_fichier_csv = 'Mesure_mensuelle_Region_Occitanie_Polluants_Principaux.csv'

# Charger le fichier CSV dans un DataFrame
df = pd.read_csv(chemin_fichier_csv)

# Créer un dégradé de couleurs pour la palette
couleurs = sns.color_palette("coolwarm", as_cmap=True)

# Créer un diagramme circulaire (camembert) pour la variable 'nom_dept'
plt.figure(figsize=(10, 8))
sns.set(style="whitegrid")  # Style de fond pour une meilleure lisibilité

# Tracer le camembert avec le dégradé de couleurs
df['nom_dept'].value_counts().plot.pie(autopct='%1.1f%%', startangle=140, cmap=couleurs)

plt.title('Répartition des données par département')
plt.axis('equal')  # Assure que le camembert est dessiné comme un cercle
plt.ylabel('')  # Supprimer l'étiquette de l'axe y pour plus de clarté

plt.show()
```

# Graphique 3D de Rodez : {background-color="#CAFFEF"}

```{.python code-line-numbers="2,3|6|9|12|15|18|21,22,23,24|27|31"}

import pandas as pd
import plotly.express as px

# Charger le fichier CSV dans un DataFrame
df = pd.read_csv('Mesure_annuelle_Region_Occitanie_Polluants_Principaux.csv')

# Filtrer les données pour la ville de RODEZ
rodez_data = df[df['nom_com'] == 'RODEZ'].copy()  # Utiliser .copy() pour éviter le SettingWithCopyWarning

# Convertir la colonne 'date_debut' en format datetime
rodez_data['date_debut'] = pd.to_datetime(rodez_data['date_debut'])

# Trier les données par date
rodez_data = rodez_data.sort_values(by='date_debut')

# Obtenir la valeur maximale de chaque polluant pour chaque année
max_values_rodez = rodez_data.groupby(['date_debut', 'nom_poll'])['valeur'].max().reset_index()

# Créer un graphique en 3D avec Plotly Express
fig_rodez = px.scatter_3d(max_values_rodez, x='date_debut', y='nom_poll', z='valeur', color='valeur',
                          labels={'valeur': f'Concentration maximale de pollution (ug.m-3)'},
                          title='Concentration maximale de pollution à RODEZ par année',
                          size_max=18)

# Personnaliser le graphique
fig_rodez.update_layout(scene=dict(xaxis_title='Année', yaxis_title='Polluant', zaxis_title='Concentration maximale de pollution (ug.m-3)'),
                        height=600, width=800)  # Ajustez ces valeurs en fonction de la taille souhaitée

# Afficher le graphique interactif
fig_rodez.show()
``` 

# Résultat : {background-color="#CAFFEF"}

```{python}
import pandas as pd
import plotly.express as px

# Charger le fichier CSV dans un DataFrame
df = pd.read_csv('Mesure_annuelle_Region_Occitanie_Polluants_Principaux.csv')

# Filtrer les données pour la ville de RODEZ
rodez_data = df[df['nom_com'] == 'RODEZ'].copy()  # Utiliser .copy() pour éviter le SettingWithCopyWarning

# Convertir la colonne 'date_debut' en format datetime
rodez_data['date_debut'] = pd.to_datetime(rodez_data['date_debut'])

# Trier les données par date
rodez_data = rodez_data.sort_values(by='date_debut')

# Obtenir la valeur maximale de chaque polluant pour chaque année
max_values_rodez = rodez_data.groupby(['date_debut', 'nom_poll'])['valeur'].max().reset_index()

# Créer un graphique en 3D avec Plotly Express
fig_rodez = px.scatter_3d(max_values_rodez, x='date_debut', y='nom_poll', z='valeur', color='valeur',
                          labels={'valeur': f'Concentration maximale de pollution (ug.m-3)'},
                          title='Concentration maximale de pollution à RODEZ par année',
                          size_max=18)

# Personnaliser le graphique
fig_rodez.update_layout(scene=dict(xaxis_title='Année', yaxis_title='Polluant', zaxis_title='Concentration maximale de pollution (ug.m-3)'),
                        height=600, width=800)  # Ajustez ces valeurs en fonction de la taille souhaitée

# Afficher le graphique interactif
fig_rodez.show()

```


# Code carte intéractive : {background-color="#CAFFEF"}

```{.python code-line-numbers="2,3|6,7,8|11,12|15|24,25,26|59|68"}
#test d'une carte des densités, interactive 
import folium
from branca.colormap import linear

# Coordonnées et populations des grandes villes de l'Occitanie (Latitude, Longitude, Population)
grandes_villes_occitanie = {
    'Toulouse': (43.6047, 1.4442, 479553),
    'Montpellier': (43.6110, 3.8767, 285121),
    'Nîmes': (43.8374, 4.3601, 151001),
    'Perpignan': (42.6986, 2.8954, 121875),
    'Carcassonne': (43.2130, 2.3491, 47038),
    'Albi': (43.9291, 2.1483, 49236),
    'Tarbes': (43.2328, 0.0716, 40356),
    'Auch': (43.6460, 0.5857, 23853),
}

# Coordonnées du centre de l'Occitanie
centre_occitanie = (43.5912, 1.4466)

# Créer une carte centrée sur l'Occitanie
carte_occitanie = folium.Map(location=centre_occitanie, zoom_start=8, tiles='Stamen Terrain')
folium.Marker(centre_occitanie, popup='Centre de l\'Occitanie', icon=folium.Icon(color='red')).add_to(carte_occitanie)
folium.TileLayer('openstreetmap').add_to(carte_occitanie)  # Ajouter une couche OpenStreetMap en arrière-plan

# Créer une colormap en fonction de la population
colormap = linear.YlOrRd_09.scale(min(grandes_villes_occitanie.values(), key=lambda x: x[2])[2],
                                  max(grandes_villes_occitanie.values(), key=lambda x: x[2])[2])

# Ajouter des marqueurs pour chaque grande ville avec une couleur correspondant à la population
for ville, coordonnees in grandes_villes_occitanie.items():
    if coordonnees[2] > 300000:
        icon = folium.Icon(color='blue', icon='star')
    elif coordonnees[2] > 100000:
        icon = folium.Icon(color='green', icon='cloud')
    else:
        icon = folium.Icon(color='red', icon='info-sign')

    folium.Marker(
        location=coordonnees[:2],
        popup=f"{ville}: {coordonnees[2]} habitants",
        icon=icon
    ).add_to(carte_occitanie)

# Utiliser une échelle log pour le rayon des cercles
for ville, coordonnees in grandes_villes_occitanie.items():
    folium.CircleMarker(
        location=coordonnees[:2],
        radius=coordonnees[2] / 50000,
        popup=f"{ville}: {coordonnees[2]} habitants",
        color=colormap(coordonnees[2]),
        fill=True,
        fill_color=colormap(coordonnees[2]),
    ).add_to(carte_occitanie)

# Personnaliser la légende
colormap.caption = 'Population et densité des grandes villes en Occitanie'
colormap.add_to(carte_occitanie)

# Afficher la carte dans le notebook
carte_occitanie



```

# Résultat : {background-color="#CAFFEF"}

```{python}
#test d'une carte des densités, interactive 
import folium
from branca.colormap import linear

# Coordonnées et populations des grandes villes de l'Occitanie (Latitude, Longitude, Population)
grandes_villes_occitanie = {
    'Toulouse': (43.6047, 1.4442, 479553),
    'Montpellier': (43.6110, 3.8767, 285121),
    'Nîmes': (43.8374, 4.3601, 151001),
    'Perpignan': (42.6986, 2.8954, 121875),
    'Carcassonne': (43.2130, 2.3491, 47038),
    'Albi': (43.9291, 2.1483, 49236),
    'Tarbes': (43.2328, 0.0716, 40356),
    'Auch': (43.6460, 0.5857, 23853),
}

# Coordonnées du centre de l'Occitanie
centre_occitanie = (43.5912, 1.4466)

# Créer une carte centrée sur l'Occitanie
carte_occitanie = folium.Map(location=centre_occitanie, zoom_start=8, tiles='Stamen Terrain')
folium.Marker(centre_occitanie, popup='Centre de l\'Occitanie', icon=folium.Icon(color='red')).add_to(carte_occitanie)
folium.TileLayer('openstreetmap').add_to(carte_occitanie)  # Ajouter une couche OpenStreetMap en arrière-plan

# Créer une colormap en fonction de la population
colormap = linear.YlOrRd_09.scale(min(grandes_villes_occitanie.values(), key=lambda x: x[2])[2],
                                  max(grandes_villes_occitanie.values(), key=lambda x: x[2])[2])

# Ajouter des marqueurs pour chaque grande ville avec une couleur correspondant à la population
for ville, coordonnees in grandes_villes_occitanie.items():
    if coordonnees[2] > 300000:
        icon = folium.Icon(color='blue', icon='star')
    elif coordonnees[2] > 100000:
        icon = folium.Icon(color='green', icon='cloud')
    else:
        icon = folium.Icon(color='red', icon='info-sign')

    folium.Marker(
        location=coordonnees[:2],
        popup=f"{ville}: {coordonnees[2]} habitants",
        icon=icon
    ).add_to(carte_occitanie)

# Utiliser une échelle log pour le rayon des cercles
for ville, coordonnees in grandes_villes_occitanie.items():
    folium.CircleMarker(
        location=coordonnees[:2],
        radius=coordonnees[2] / 50000 * 10,  # Ajustez le facteur de multiplication ici
        popup=f"{ville}: {coordonnees[2]} habitants",
        color=colormap(coordonnees[2]),
        fill=True,
        fill_color=colormap(coordonnees[2]),
    ).add_to(carte_occitanie)

# Personnaliser la légende
colormap.caption = 'Population et densité des grandes villes en Occitanie'
colormap.add_to(carte_occitanie)

# Afficher la carte dans le notebook
carte_occitanie




```



# Hiérarchie des villes en fonction des polluants :{background-color="#CAFFEF"} 

# Suspens ... {background-color="#353535"}



#  {background-image="classement.svg"}


# Problèmes rencontrés : {background-image="brain1.svg" background-opacity="0.5" background-size="600px" background-position="bottom" }

- Création de la page web 
- Compréhension de Quarto 
- intégrer du code sans que le code ne s'Affiche
- gérer un ficher .yml et .css
- Importer les données météos 
- Gérer le rangement sur le repository 
- Nettoyage de fichier csv 
 

# Cohérence avec le diagramme de Gantt ?{background-color="#CAFFEF"} 
